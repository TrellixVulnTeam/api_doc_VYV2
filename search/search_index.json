{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chrysalis \u00b6 Chrysalis Cloud is the first seamless, low-cost video streaming platform that enables real-time video analytics in the cloud. Laying the foundations for video intelligence, seamless video streaming and management for real-time AI.","title":"Home"},{"location":"#chrysalis","text":"Chrysalis Cloud is the first seamless, low-cost video streaming platform that enables real-time video analytics in the cloud. Laying the foundations for video intelligence, seamless video streaming and management for real-time AI.","title":"Chrysalis"},{"location":"ccloud/","text":"Chrysalis Cloud \u00b6","title":"Chrysalis Cloud"},{"location":"ccloud/#chrysalis-cloud","text":"","title":"Chrysalis Cloud"},{"location":"cedge/","text":"Chrysalis Cloud Video-Edge-AI-Proxy \u00b6 The ultimate video pipeline for Computer Vision. The video-edge-ai-proxy ingests multiple RTSP camera streams and provides a common interface for conducting AI operations on or near the Edge. The video-edge-ai-proxy is an easy to use collection mechanism from multiple cameras onto a single more powerful computer. For example, a network of CCTV RTSP enabled cameras can be accessed through a simple GRPC interface, where Machine Learning algorithms can do various Computer Vision tasks. Furthermore, interesting footage can be annotated, selectively streamed and stored through a simple API for later analysis, computer vision tasks in the cloud or enriching the Machine Learning training samples.","title":"Chrysalis Cloud Video-Edge-AI-Proxy"},{"location":"cedge/#chrysalis-cloud-video-edge-ai-proxy","text":"The ultimate video pipeline for Computer Vision. The video-edge-ai-proxy ingests multiple RTSP camera streams and provides a common interface for conducting AI operations on or near the Edge. The video-edge-ai-proxy is an easy to use collection mechanism from multiple cameras onto a single more powerful computer. For example, a network of CCTV RTSP enabled cameras can be accessed through a simple GRPC interface, where Machine Learning algorithms can do various Computer Vision tasks. Furthermore, interesting footage can be annotated, selectively streamed and stored through a simple API for later analysis, computer vision tasks in the cloud or enriching the Machine Learning training samples.","title":"Chrysalis Cloud Video-Edge-AI-Proxy"},{"location":"cloud/comingsoon/","text":"This is a sample space \u00b6 Example tabs \u00b6","title":"Coming Soon"},{"location":"cloud/comingsoon/#this-is-a-sample-space","text":"","title":"This is a sample space"},{"location":"cloud/comingsoon/#example-tabs","text":"","title":"Example tabs"},{"location":"edge-proxy/features/","text":"Features \u00b6 RTSP camera hub \u00b6 User interface and RESTful API for setting up multiple RTSP cameras Connection management \u00b6 Handles cases of internet outages or camera streaming problems Stream management \u00b6 Deals with the complexities of stream management Video/Image Hub \u00b6 Processing of images from multiple camera sources simultaneously Optimized \u00b6 Optimized for processing multiple camera streams in parallel Selective Frames \u00b6 Can read I-Frames also known as Keyframes or Frames within any time interval while skipping decoding of packets when possible Selective Pass-Through \u00b6 Selective streaming, Start and Stop, for preserving bandwidth Selective Pass-Through-Storage \u00b6 On and Off switch for storing a portion of a stream forwarded to Chrysalis Cloud Machine Learning Annotation \u00b6 Asynchronous annotations for live video streams","title":"Features"},{"location":"edge-proxy/features/#features","text":"","title":"Features"},{"location":"edge-proxy/features/#rtsp-camera-hub","text":"User interface and RESTful API for setting up multiple RTSP cameras","title":"RTSP camera hub"},{"location":"edge-proxy/features/#connection-management","text":"Handles cases of internet outages or camera streaming problems","title":"Connection management"},{"location":"edge-proxy/features/#stream-management","text":"Deals with the complexities of stream management","title":"Stream management"},{"location":"edge-proxy/features/#videoimage-hub","text":"Processing of images from multiple camera sources simultaneously","title":"Video/Image Hub"},{"location":"edge-proxy/features/#optimized","text":"Optimized for processing multiple camera streams in parallel","title":"Optimized"},{"location":"edge-proxy/features/#selective-frames","text":"Can read I-Frames also known as Keyframes or Frames within any time interval while skipping decoding of packets when possible","title":"Selective Frames"},{"location":"edge-proxy/features/#selective-pass-through","text":"Selective streaming, Start and Stop, for preserving bandwidth","title":"Selective Pass-Through"},{"location":"edge-proxy/features/#selective-pass-through-storage","text":"On and Off switch for storing a portion of a stream forwarded to Chrysalis Cloud","title":"Selective Pass-Through-Storage"},{"location":"edge-proxy/features/#machine-learning-annotation","text":"Asynchronous annotations for live video streams","title":"Machine Learning Annotation"},{"location":"edge-proxy/homepage/","text":"Chrysalis Cloud Video-Edge-AI-Proxy \u00b6 The ultimate video pipeline for Computer Vision. The video-edge-ai-proxy ingests multiple RTSP camera streams and provides a common interface for conducting AI operations on or near the Edge. The video-edge-ai-proxy is an easy to use collection mechanism from multiple cameras onto a single more powerful computer. For example, a network of CCTV RTSP enabled cameras can be accessed through a simple GRPC interface, where Machine Learning algorithms can do various Computer Vision tasks. Furthermore, interesting footage can be annotated, selectively streamed and stored through a simple API for later analysis, computer vision tasks in the cloud or enriching the Machine Learning training samples.","title":"Home"},{"location":"edge-proxy/homepage/#chrysalis-cloud-video-edge-ai-proxy","text":"The ultimate video pipeline for Computer Vision. The video-edge-ai-proxy ingests multiple RTSP camera streams and provides a common interface for conducting AI operations on or near the Edge. The video-edge-ai-proxy is an easy to use collection mechanism from multiple cameras onto a single more powerful computer. For example, a network of CCTV RTSP enabled cameras can be accessed through a simple GRPC interface, where Machine Learning algorithms can do various Computer Vision tasks. Furthermore, interesting footage can be annotated, selectively streamed and stored through a simple API for later analysis, computer vision tasks in the cloud or enriching the Machine Learning training samples.","title":"Chrysalis Cloud Video-Edge-AI-Proxy"},{"location":"edge-proxy/apis/rest_api/","text":"Chrysalis Clouds' REST APIs \u00b6 The Chrysalis Clouds' video-edge-ai-proxy server exposes RESTful APIs for stream management. With these APIs you can start, stop, delete, and list the rtmp_to_rtsp containers. Start rtsp container \u00b6 Start a new rtsp stream process Go func ( ph * rtspProcessHandler ) StartRTSP ( c * gin . Context ) { var streamProcess models . StreamProcess if err := c . ShouldBindWith ( & streamProcess , binding . JSON ); err != nil { g . Log . Warn ( \"missing required fields\" , err ) AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } if streamProcess . RTSPEndpoint == \"\" { AbortWithError ( c , http . StatusBadRequest , \"RTP endpoint required\" ) return } deviceID := streamProcess . Name if streamProcess . Name == \"\" { hash := fmt . Sprintf ( \"%x\" , md5 . Sum ([] byte ( streamProcess . RTSPEndpoint ))) deviceID = hash } streamProcess . RTMPStreamStatus = & models . RTMPStreamStatus { Storing : false , Streaming : true , } rtspImageTag := models . CameraTypeToImageTag [ \"rtsp\" ] currentImagesList , err := ph . settingsManager . ListDockerImages ( rtspImageTag ) if err != nil { g . Log . Error ( \"failed to list currently available images\" , err ) AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } err = ph . processManager . Start ( & streamProcess , currentImagesList ) if err != nil { g . Log . Warn ( \"failed to start process \" , deviceID , err ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . Status ( http . StatusOK ) } Find upgrades \u00b6 Check if each process has an upgradable version available on local disk Go func ( ph * rtspProcessHandler ) FindRTSPUpgrades ( c * gin . Context ) { imageTag := models . CameraTypeToImageTag [ \"rtsp\" ] imageUpgrade , err := ph . settingsManager . ListDockerImages ( imageTag ) if err != nil { AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } upgrades , err := ph . processManager . FindUpgrades ( imageUpgrade ) if err != nil { g . Log . Error ( \"failed finding image upgrades\" , err ) AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } c . JSON ( http . StatusOK , upgrades ) } Upgrade Container \u00b6 Upgrade a running container for specific process Go func ( ph * rtspProcessHandler ) UpgradeContainer ( c * gin . Context ) { var process models . StreamProcess if err := c . ShouldBindWith ( & process , binding . JSON ); err != nil { g . Log . Warn ( \"missing required fields\" , err ) AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } if process . ImageTag == \"\" { AbortWithError ( c , http . StatusBadRequest , \"imagetag is empty on StreamProcess\" ) return } splitted := strings . Split ( process . ImageTag , \":\" ) if len ( splitted ) != 2 { AbortWithError ( c , http . StatusBadRequest , \"invalid image. tag (verion) required\" ) return } baseTag := splitted [ 0 ] newProc , err := ph . processManager . UpgradeRunningContainer ( & process , baseTag + \":\" + process . NewerVersion ) if err != nil { g . Log . Error ( \"failed to upgrade running container\" , process . Name , process . ImageTag ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . JSON ( http . StatusOK , newProc ) } Stop \u00b6 Stop a running rtsp process GO func ( ph * rtspProcessHandler ) Stop ( c * gin . Context ) { deviceID := c . Param ( \"name\" ) if deviceID == \"\" { AbortWithError ( c , http . StatusBadRequest , \"required device_id\" ) return } err := ph . processManager . Stop ( deviceID ) if err != nil { g . Log . Warn ( \"failed to start process \" , deviceID , err ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . Status ( http . StatusOK ) } Info \u00b6 Get information about a particular process Go func ( ph * rtspProcessHandler ) Info ( c * gin . Context ) { deviceID := c . Param ( \"name\" ) if deviceID == \"\" { AbortWithError ( c , http . StatusBadRequest , \"required device_id\" ) return } info , err := ph . processManager . Info ( deviceID ) if err != nil { AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } c . JSON ( http . StatusOK , info ) } List \u00b6 List all the processes that are in any state Go func ( ph * rtspProcessHandler ) List ( c * gin . Context ) { processes , err := ph . processManager . List () if err != nil { AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } c . JSON ( http . StatusOK , processes ) }","title":"REST API"},{"location":"edge-proxy/apis/rest_api/#chrysalis-clouds-rest-apis","text":"The Chrysalis Clouds' video-edge-ai-proxy server exposes RESTful APIs for stream management. With these APIs you can start, stop, delete, and list the rtmp_to_rtsp containers.","title":"Chrysalis Clouds' REST APIs"},{"location":"edge-proxy/apis/rest_api/#start-rtsp-container","text":"Start a new rtsp stream process Go func ( ph * rtspProcessHandler ) StartRTSP ( c * gin . Context ) { var streamProcess models . StreamProcess if err := c . ShouldBindWith ( & streamProcess , binding . JSON ); err != nil { g . Log . Warn ( \"missing required fields\" , err ) AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } if streamProcess . RTSPEndpoint == \"\" { AbortWithError ( c , http . StatusBadRequest , \"RTP endpoint required\" ) return } deviceID := streamProcess . Name if streamProcess . Name == \"\" { hash := fmt . Sprintf ( \"%x\" , md5 . Sum ([] byte ( streamProcess . RTSPEndpoint ))) deviceID = hash } streamProcess . RTMPStreamStatus = & models . RTMPStreamStatus { Storing : false , Streaming : true , } rtspImageTag := models . CameraTypeToImageTag [ \"rtsp\" ] currentImagesList , err := ph . settingsManager . ListDockerImages ( rtspImageTag ) if err != nil { g . Log . Error ( \"failed to list currently available images\" , err ) AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } err = ph . processManager . Start ( & streamProcess , currentImagesList ) if err != nil { g . Log . Warn ( \"failed to start process \" , deviceID , err ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . Status ( http . StatusOK ) }","title":"Start rtsp container"},{"location":"edge-proxy/apis/rest_api/#find-upgrades","text":"Check if each process has an upgradable version available on local disk Go func ( ph * rtspProcessHandler ) FindRTSPUpgrades ( c * gin . Context ) { imageTag := models . CameraTypeToImageTag [ \"rtsp\" ] imageUpgrade , err := ph . settingsManager . ListDockerImages ( imageTag ) if err != nil { AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } upgrades , err := ph . processManager . FindUpgrades ( imageUpgrade ) if err != nil { g . Log . Error ( \"failed finding image upgrades\" , err ) AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } c . JSON ( http . StatusOK , upgrades ) }","title":"Find upgrades"},{"location":"edge-proxy/apis/rest_api/#upgrade-container","text":"Upgrade a running container for specific process Go func ( ph * rtspProcessHandler ) UpgradeContainer ( c * gin . Context ) { var process models . StreamProcess if err := c . ShouldBindWith ( & process , binding . JSON ); err != nil { g . Log . Warn ( \"missing required fields\" , err ) AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } if process . ImageTag == \"\" { AbortWithError ( c , http . StatusBadRequest , \"imagetag is empty on StreamProcess\" ) return } splitted := strings . Split ( process . ImageTag , \":\" ) if len ( splitted ) != 2 { AbortWithError ( c , http . StatusBadRequest , \"invalid image. tag (verion) required\" ) return } baseTag := splitted [ 0 ] newProc , err := ph . processManager . UpgradeRunningContainer ( & process , baseTag + \":\" + process . NewerVersion ) if err != nil { g . Log . Error ( \"failed to upgrade running container\" , process . Name , process . ImageTag ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . JSON ( http . StatusOK , newProc ) }","title":"Upgrade Container"},{"location":"edge-proxy/apis/rest_api/#stop","text":"Stop a running rtsp process GO func ( ph * rtspProcessHandler ) Stop ( c * gin . Context ) { deviceID := c . Param ( \"name\" ) if deviceID == \"\" { AbortWithError ( c , http . StatusBadRequest , \"required device_id\" ) return } err := ph . processManager . Stop ( deviceID ) if err != nil { g . Log . Warn ( \"failed to start process \" , deviceID , err ) AbortWithError ( c , http . StatusConflict , err . Error ()) return } c . Status ( http . StatusOK ) }","title":"Stop"},{"location":"edge-proxy/apis/rest_api/#info","text":"Get information about a particular process Go func ( ph * rtspProcessHandler ) Info ( c * gin . Context ) { deviceID := c . Param ( \"name\" ) if deviceID == \"\" { AbortWithError ( c , http . StatusBadRequest , \"required device_id\" ) return } info , err := ph . processManager . Info ( deviceID ) if err != nil { AbortWithError ( c , http . StatusBadRequest , err . Error ()) return } c . JSON ( http . StatusOK , info ) }","title":"Info"},{"location":"edge-proxy/apis/rest_api/#list","text":"List all the processes that are in any state Go func ( ph * rtspProcessHandler ) List ( c * gin . Context ) { processes , err := ph . processManager . List () if err != nil { AbortWithError ( c , http . StatusInternalServerError , err . Error ()) return } c . JSON ( http . StatusOK , processes ) }","title":"List"},{"location":"edge-proxy/build-from-source/bfs/","text":"Building from source \u00b6 Clone repository \u00b6 Clone the Chrysalis Cloud video-edge-ai-proxy repo from guthub: git clone https://github.com/chryscloud/video-edge-ai-proxy.git The video-edge-ai-proxy stores running processes, one for each connected camera, into a local datastore hosted on your file system. By default the folder path used is: /data/chrysalis create this folder if it doesn't exist and make sure it's writable by docker process. Docker run \u00b6 In case you cloned this repository you can run docker-compose with build command. Start video-edge-ai-proxy with local build: docker-compose up -d or docker-compose build","title":"Building from Source"},{"location":"edge-proxy/build-from-source/bfs/#building-from-source","text":"","title":"Building from source"},{"location":"edge-proxy/build-from-source/bfs/#clone-repository","text":"Clone the Chrysalis Cloud video-edge-ai-proxy repo from guthub: git clone https://github.com/chryscloud/video-edge-ai-proxy.git The video-edge-ai-proxy stores running processes, one for each connected camera, into a local datastore hosted on your file system. By default the folder path used is: /data/chrysalis create this folder if it doesn't exist and make sure it's writable by docker process.","title":"Clone repository"},{"location":"edge-proxy/build-from-source/bfs/#docker-run","text":"In case you cloned this repository you can run docker-compose with build command. Start video-edge-ai-proxy with local build: docker-compose up -d or docker-compose build","title":"Docker run"},{"location":"edge-proxy/custom-configuration/chrysalis-config/","text":"Custom Chrysalis configuration \u00b6 Create conf.yaml file in the location: Linux /data/chrysalis folder Mac OS X on_disk_folder custom folder created during setup Windows on_disk_folder by prefixing with /C/ Example: on_disk_folder: /C/Users/user/chrys-video-egde-proxy/videos The configuration file is automatically picked up if it exists otherwise system fallbacks to it's default configuration. Configuration \u00b6 version: 0.0.3 title: Chrysalis Video Edge Proxy description: Chrysalis Video Edge Proxy Service for Computer Vision mode: release # \"debug\": or \"release\" redis: connection: \"redis:6379\" database: 0 password: \"\" api: endpoint: https://api.chryscloud.com annotation: endpoint: \"https://event.chryscloud.com/api/v1/annotate\" unacked_limit: 1000 poll_duration_ms: 300 max_batch_size: 299 buffer: in_memory: 1 # number of images to store in memory buffer (1 = default) on_disk: false # store key-frame separated mp4 file segments to disk on_disk_folder: /data/chrysalis/archive # can be any custom folder you'd like to store video segments to on_disk_clean_older_than: \"5m\" # remove older mp4 segments than 5m mode: release : disables debug mode for http server (default: release) redis -> connection : redis host with port (default: \"redis:6379\") redis -> database : 0 - 15. 0 is redis default database. (default: 0) redis -> password : optional redis password (default: \"\") api -> endpoint : chrysalis API location for remote signaling such as enable/disable storage (default: https://api.chryscloud.com ) annotation -> endpoint : Crysalis Cloud annotation endpoint (default: https://event.chryscloud.com/api/v1/annotate ) annotation -> unacked limit : maximum number of unacknowledged annotatoons (default: 299) annotation -> poll_duration_ms : poll every x miliseconds for batching purposes (default: 300ms) annotation -> max_match_size : maximum number of annotation per batch size (default: 299) buffer -> in_memory : number of decoded frames to store in memory per camera (default: 1) on_disk : true/false, store key-frame chunked mp4 files to disk (default: false) on_disk_folder : path to the folder where segments will be stored on_disk_clean_older_than : remove mp4 segments older than (default: 5m) on_disk_schedule : run disk cleanup scheduler cron job #https://en.wikipedia.org/wiki/Cron on_disk creates mp4 segments in format: \"current_timestamp in ms\"_\"duration_in_ms\".mp4 . For example: 1600685088000_2000.mp4","title":"Custom Chrysalis configuration"},{"location":"edge-proxy/custom-configuration/chrysalis-config/#custom-chrysalis-configuration","text":"Create conf.yaml file in the location: Linux /data/chrysalis folder Mac OS X on_disk_folder custom folder created during setup Windows on_disk_folder by prefixing with /C/ Example: on_disk_folder: /C/Users/user/chrys-video-egde-proxy/videos The configuration file is automatically picked up if it exists otherwise system fallbacks to it's default configuration.","title":"Custom Chrysalis configuration"},{"location":"edge-proxy/custom-configuration/chrysalis-config/#configuration","text":"version: 0.0.3 title: Chrysalis Video Edge Proxy description: Chrysalis Video Edge Proxy Service for Computer Vision mode: release # \"debug\": or \"release\" redis: connection: \"redis:6379\" database: 0 password: \"\" api: endpoint: https://api.chryscloud.com annotation: endpoint: \"https://event.chryscloud.com/api/v1/annotate\" unacked_limit: 1000 poll_duration_ms: 300 max_batch_size: 299 buffer: in_memory: 1 # number of images to store in memory buffer (1 = default) on_disk: false # store key-frame separated mp4 file segments to disk on_disk_folder: /data/chrysalis/archive # can be any custom folder you'd like to store video segments to on_disk_clean_older_than: \"5m\" # remove older mp4 segments than 5m mode: release : disables debug mode for http server (default: release) redis -> connection : redis host with port (default: \"redis:6379\") redis -> database : 0 - 15. 0 is redis default database. (default: 0) redis -> password : optional redis password (default: \"\") api -> endpoint : chrysalis API location for remote signaling such as enable/disable storage (default: https://api.chryscloud.com ) annotation -> endpoint : Crysalis Cloud annotation endpoint (default: https://event.chryscloud.com/api/v1/annotate ) annotation -> unacked limit : maximum number of unacknowledged annotatoons (default: 299) annotation -> poll_duration_ms : poll every x miliseconds for batching purposes (default: 300ms) annotation -> max_match_size : maximum number of annotation per batch size (default: 299) buffer -> in_memory : number of decoded frames to store in memory per camera (default: 1) on_disk : true/false, store key-frame chunked mp4 files to disk (default: false) on_disk_folder : path to the folder where segments will be stored on_disk_clean_older_than : remove mp4 segments older than (default: 5m) on_disk_schedule : run disk cleanup scheduler cron job #https://en.wikipedia.org/wiki/Cron on_disk creates mp4 segments in format: \"current_timestamp in ms\"_\"duration_in_ms\".mp4 . For example: 1600685088000_2000.mp4","title":"Configuration"},{"location":"edge-proxy/custom-configuration/redis-config/","text":"Custom redis configuration \u00b6 Default configuration is in the root folder of the project: ./redis.conf Update default redis.conf in the root directory of the project Uncomment volumes section in redis config # volumes: # - /data/chrysalis/redis:/data # - ./redis.conf:/usr/local/etc/redis/redis.conf # command: # - redis-server # - /usr/local/etc/redis/redis.conf Modify folders accordingly for Mac OS X and Windows","title":"Custom redis configuration"},{"location":"edge-proxy/custom-configuration/redis-config/#custom-redis-configuration","text":"Default configuration is in the root folder of the project: ./redis.conf Update default redis.conf in the root directory of the project Uncomment volumes section in redis config # volumes: # - /data/chrysalis/redis:/data # - ./redis.conf:/usr/local/etc/redis/redis.conf # command: # - redis-server # - /usr/local/etc/redis/redis.conf Modify folders accordingly for Mac OS X and Windows","title":"Custom redis configuration"},{"location":"edge-proxy/examples/basic-usage/","text":"Executing basic usage script \u00b6 List all stream processes: python basic_usage.py --list Successful output example: name: \"test\" status: \"running\" pid: 18109 running: true Output single streaming frame information from test camera: python basic_usage.py --device test Successful output example: is keyframe: False frame type: P frame shape: dim { size: 480 name: \"0\" } dim { size: 640 name: \"1\" } dim { size: 3 name: \"2\" } is_keyframe: True/False frame type: I,P,B frame shape: Image dimensions, disaplyed always in BGR24 format In this example: 480x640x3 bgr24","title":"Basic Usage"},{"location":"edge-proxy/examples/basic-usage/#executing-basic-usage-script","text":"List all stream processes: python basic_usage.py --list Successful output example: name: \"test\" status: \"running\" pid: 18109 running: true Output single streaming frame information from test camera: python basic_usage.py --device test Successful output example: is keyframe: False frame type: P frame shape: dim { size: 480 name: \"0\" } dim { size: 640 name: \"1\" } dim { size: 3 name: \"2\" } is_keyframe: True/False frame type: I,P,B frame shape: Image dimensions, disaplyed always in BGR24 format In this example: 480x640x3 bgr24","title":"Executing basic usage script"},{"location":"edge-proxy/examples/display/","text":"Executing OpenCV display script \u00b6 Display video at original frame rate for test camera: python opencv_display.py --device test Display only Keyframes for test camera: python opencv_display.py --device test --keyframe","title":"OpenCV Display"},{"location":"edge-proxy/examples/display/#executing-opencv-display-script","text":"Display video at original frame rate for test camera: python opencv_display.py --device test Display only Keyframes for test camera: python opencv_display.py --device test --keyframe","title":"Executing OpenCV display script"},{"location":"edge-proxy/examples/prerequisites/","text":"Prerequisites to execute examples \u00b6 Create conda environment: conda env create -f examples/environment.yml Activate environment: conda activate chrysedgeexamples cd examples Generate python grpc stubs: make examples","title":"Prerequisites"},{"location":"edge-proxy/examples/prerequisites/#prerequisites-to-execute-examples","text":"Create conda environment: conda env create -f examples/environment.yml Activate environment: conda activate chrysedgeexamples cd examples Generate python grpc stubs: make examples","title":"Prerequisites to execute examples"},{"location":"edge-proxy/examples/storage-onoff/","text":"Executing Storage On/Off script \u00b6 Storage example turns Chrysalis Cloud storage On or Off for the current live stream from the cameras. Run example to turn storage on for camera test : python storage_onoff.py --device test --on true Run example to turn storage off for camera test : python storage_onoff.py --device test --on false:","title":"Storage"},{"location":"edge-proxy/examples/storage-onoff/#executing-storage-onoff-script","text":"Storage example turns Chrysalis Cloud storage On or Off for the current live stream from the cameras. Run example to turn storage on for camera test : python storage_onoff.py --device test --on true Run example to turn storage off for camera test : python storage_onoff.py --device test --on false:","title":"Executing Storage On/Off script"},{"location":"edge-proxy/getting-started/portal-usage/","text":"Portal Usage \u00b6 Open your browser and visit : http://localhost:8905 On the first visit, Edge Proxy will display a RTSP docker container icon. Click on it. This will initiate the pull for the latest version of the docker container pre-compiled to be used with RTSP enabled cameras. Connecting RTSP camera \u00b6 Click: Connect RTSP Camera in the Chrysalis portal and name the camera Insert full RTSP link and if credentials are required add them to the link Example RTSP url \u00b6 With credentials rtsp://admin:12345@192.168.1.21/Streaming/Channels/101 Without credentials rtsp://192.168.1.21:8554/unicast Click on the newly created connection and check the output and error log. Expected state is running and the output message Started python rtsp process... Chrysalis Portal \u00b6 Client Usage \u00b6 At this point you should have the video-edge-ai-proxy up and running and your first connection to RTSP camera established.","title":"Portal Usage"},{"location":"edge-proxy/getting-started/portal-usage/#portal-usage","text":"Open your browser and visit : http://localhost:8905 On the first visit, Edge Proxy will display a RTSP docker container icon. Click on it. This will initiate the pull for the latest version of the docker container pre-compiled to be used with RTSP enabled cameras.","title":"Portal Usage"},{"location":"edge-proxy/getting-started/portal-usage/#connecting-rtsp-camera","text":"Click: Connect RTSP Camera in the Chrysalis portal and name the camera Insert full RTSP link and if credentials are required add them to the link","title":"Connecting RTSP camera"},{"location":"edge-proxy/getting-started/portal-usage/#example-rtsp-url","text":"With credentials rtsp://admin:12345@192.168.1.21/Streaming/Channels/101 Without credentials rtsp://192.168.1.21:8554/unicast Click on the newly created connection and check the output and error log. Expected state is running and the output message Started python rtsp process...","title":"Example RTSP url"},{"location":"edge-proxy/getting-started/portal-usage/#chrysalis-portal","text":"","title":"Chrysalis Portal"},{"location":"edge-proxy/getting-started/portal-usage/#client-usage","text":"At this point you should have the video-edge-ai-proxy up and running and your first connection to RTSP camera established.","title":"Client Usage"},{"location":"edge-proxy/getting-started/prerequisites/","text":"Prerequisites \u00b6 Install Docker Engine \u00b6 Docker Install Docker Compose \u00b6 Docker Compose Enable docker TCP socket connection \u00b6 This setting is required only for Linux based systems. If you are running on Mac OS X or Windows use the latest version of docker-compose and docker. Create daemon.json file in etc/docker folder with JSON contents: { \"hosts\": [ \"fd://\", \"unix:///var/run/docker.sock\" ] } Create a new file /etc/systemd/system/docker.service.d/docker.conf with the following contents: [Service] ExecStart= ExecStart=/usr/bin/dockerd Reload daemon: sudo systemctl daemon-reload Restart docker: sudo service docker restart You can test out if the configuration is correct by issuing curl request docker socket: curl -s --unix-socket /var/run/docker.sock http://dummy/images/json | jq '.'","title":"Prerequisites"},{"location":"edge-proxy/getting-started/prerequisites/#prerequisites","text":"","title":"Prerequisites"},{"location":"edge-proxy/getting-started/prerequisites/#install-docker-engine","text":"Docker","title":"Install Docker Engine"},{"location":"edge-proxy/getting-started/prerequisites/#install-docker-compose","text":"Docker Compose","title":"Install Docker Compose"},{"location":"edge-proxy/getting-started/prerequisites/#enable-docker-tcp-socket-connection","text":"This setting is required only for Linux based systems. If you are running on Mac OS X or Windows use the latest version of docker-compose and docker. Create daemon.json file in etc/docker folder with JSON contents: { \"hosts\": [ \"fd://\", \"unix:///var/run/docker.sock\" ] } Create a new file /etc/systemd/system/docker.service.d/docker.conf with the following contents: [Service] ExecStart= ExecStart=/usr/bin/dockerd Reload daemon: sudo systemctl daemon-reload Restart docker: sudo service docker restart You can test out if the configuration is correct by issuing curl request docker socket: curl -s --unix-socket /var/run/docker.sock http://dummy/images/json | jq '.'","title":"Enable docker TCP socket connection"},{"location":"edge-proxy/getting-started/quick-start/","text":"Quick Start \u00b6 By default video-edge-ai-proxy requires these ports: 8905 for web portal 8909 for RESTful API (portal API) 50001 for client grpc connection 6379 for redis Make sure these ports are available before you start. Setup directory \u00b6 Create a directory under chrysedgeserver -> volumes : Linux /data/chrysalis Mac OS X and Windows /Users/usename/data Compose docker file \u00b6 Copy and paste below contents into a docker-compose.yml file and save it to the folder of your choice, recommended to be different than /data/chrysalis : version: '3.8' services: chrysedgeportal: image: chryscloud/chrysedgeportal:0.0.6 depends_on: - chrysedgeserver - redis ports: - \"8905:8905\" networks: - chrysnet chrysedgeserver: image: chryscloud/chrysedgeserver:0.0.6 restart: always depends_on: - redis entrypoint: /app/main ports: - \"8909:8909\" - \"50001:50001\" volumes: - /data/chrysalis:/data/chrysalis - /var/run/docker.sock:/var/run/docker.sock networks: - chrysnet redis: image: \"redis:alpine\" ports: - \"6379:6379\" networks: - chrysnet networks: chrysnet: name: chrysnet Start Video Edge AI Proxy \u00b6 Run the command: docker-compose pull docker-compose up -d --no-build Open browser and visit chrysalisportal at address: http://localhost:8905","title":"Quick Start"},{"location":"edge-proxy/getting-started/quick-start/#quick-start","text":"By default video-edge-ai-proxy requires these ports: 8905 for web portal 8909 for RESTful API (portal API) 50001 for client grpc connection 6379 for redis Make sure these ports are available before you start.","title":"Quick Start"},{"location":"edge-proxy/getting-started/quick-start/#setup-directory","text":"Create a directory under chrysedgeserver -> volumes : Linux /data/chrysalis Mac OS X and Windows /Users/usename/data","title":"Setup directory"},{"location":"edge-proxy/getting-started/quick-start/#compose-docker-file","text":"Copy and paste below contents into a docker-compose.yml file and save it to the folder of your choice, recommended to be different than /data/chrysalis : version: '3.8' services: chrysedgeportal: image: chryscloud/chrysedgeportal:0.0.6 depends_on: - chrysedgeserver - redis ports: - \"8905:8905\" networks: - chrysnet chrysedgeserver: image: chryscloud/chrysedgeserver:0.0.6 restart: always depends_on: - redis entrypoint: /app/main ports: - \"8909:8909\" - \"50001:50001\" volumes: - /data/chrysalis:/data/chrysalis - /var/run/docker.sock:/var/run/docker.sock networks: - chrysnet redis: image: \"redis:alpine\" ports: - \"6379:6379\" networks: - chrysnet networks: chrysnet: name: chrysnet","title":"Compose docker file"},{"location":"edge-proxy/getting-started/quick-start/#start-video-edge-ai-proxy","text":"Run the command: docker-compose pull docker-compose up -d --no-build Open browser and visit chrysalisportal at address: http://localhost:8905","title":"Start Video Edge AI Proxy"}]}